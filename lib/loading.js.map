{"version":3,"sources":["../src/loading.js"],"names":["loadSchema","loadAndMergeQueryDocuments","schemaPath","existsSync","schemaData","require","data","__schema","inputPaths","err","files","Error","sources","map","inputPath","body","readFileSync","filter","source"],"mappings":";;;;;QAegBA,U,GAAAA,U;QAYAC,0B,GAAAA,0B;;AA3BhB;;;;AACA;;;;AACA;;;;AAEA;;AAOA;;;;AAEA;;;;AAEO,SAASD,UAAT,CAAoBE,UAApB,EAAgC;AACrC,MAAI,CAAC,aAAGC,UAAH,CAAcD,UAAd,CAAL,EAAgC;AAC9B,UAAM,sBAAe,oCAAmCA,UAAW,EAA7D,CAAN;AACD;AACD,QAAME,aAAaC,QAAQH,UAAR,CAAnB;;AAEA,MAAI,CAACE,WAAWE,IAAZ,IAAoB,CAACF,WAAWG,QAApC,EAA8C;AAC5C,UAAM,sBAAc,+EAAd,CAAN;AACD;AACD,SAAO,gCAAmBH,WAAWE,IAAZ,GAAoBF,WAAWE,IAA/B,GAAsCF,UAAxD,CAAP;AACD;;AAEM,SAASH,0BAAT,CAAoCO,UAApC,EAAgD;AACrD,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,wBAAKA,UAAL,EAAiB,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAC/B,UAAID,GAAJ,EAAS,MAAM,IAAIE,KAAJ,CAAUF,GAAV,CAAN;AACTD,mBAAaE,KAAb;AACD,KAHD;AAID;AACD,QAAME,UAAUJ,WAAWK,GAAX,CAAeC,aAAa;AAC1C,UAAMC,OAAO,aAAGC,YAAH,CAAgBF,SAAhB,EAA2B,MAA3B,CAAb;AACA,QAAI,CAACC,IAAL,EAAW;AACT,aAAO,IAAP;AACD;AACD,WAAO,oBAAWA,IAAX,EAAiBD,SAAjB,CAAP;AACD,GANe,EAMbG,MANa,CAMNC,UAAUA,MANJ,CAAhB;;AAQA,SAAO,wBAAUN,QAAQC,GAAR,CAAYK,UAAU,oBAAMA,MAAN,CAAtB,CAAV,CAAP;AACD","file":"loading.js","sourcesContent":["import path from 'path'\r\nimport fs from 'fs'\r\nimport mkdirp from 'mkdirp'\r\n\r\nimport {\r\n  buildClientSchema,\r\n  Source,\r\n  concatAST,\r\n  parse\r\n} from 'graphql';\r\n\r\nimport glob from 'glob';\r\n\r\nimport { ToolError, logError } from './errors'\r\n\r\nexport function loadSchema(schemaPath) {\r\n  if (!fs.existsSync(schemaPath)) {\r\n    throw new ToolError(`Cannot find GraphQL schema file: ${schemaPath}`);\r\n  }\r\n  const schemaData = require(schemaPath);\r\n\r\n  if (!schemaData.data && !schemaData.__schema) {\r\n    throw new ToolError('GraphQL schema file should contain a valid GraphQL introspection query result');\r\n  }\r\n  return buildClientSchema((schemaData.data) ? schemaData.data : schemaData);\r\n}\r\n\r\nexport function loadAndMergeQueryDocuments(inputPaths) {\r\n  if (typeof inputPaths === \"string\") {\r\n    glob(inputPaths, (err, files) => {\r\n      if (err) throw new Error(err);\r\n      inputPaths = files;\r\n    })\r\n  }\r\n  const sources = inputPaths.map(inputPath => {\r\n    const body = fs.readFileSync(inputPath, 'utf8')\r\n    if (!body) {\r\n      return null;\r\n    }\r\n    return new Source(body, inputPath);\r\n  }).filter(source => source);\r\n\r\n  return concatAST(sources.map(source => parse(source)));\r\n}\r\n"]}