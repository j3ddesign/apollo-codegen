{"version":3,"sources":["../src/compilation.js"],"names":["compileToIR","printIR","builtInScalarTypes","isBuiltInScalarType","type","has","schema","document","compiler","Compiler","operations","forEach","operation","name","value","compileOperation","fragments","fragment","compileFragment","typesUsed","constructor","typesUsedSet","fragmentMap","definition","definitions","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","compiledFragmentMap","addTypeUsed","add","field","getFields","fragmentNamed","fragmentName","operationDefinition","filePath","operationName","operationType","variables","variableDefinitions","map","node","variable","source","withTypenameFieldAddedWhereNeeded","rootType","groupedVisitedFragmentSet","groupedFieldSet","collectFields","selectionSet","undefined","fragmentsReferencedSet","resolveFields","fields","fragmentsReferenced","fragmentDefinition","typeCondition","fragmentSpreads","inlineFragments","parentType","Error","String","selection","selections","FIELD","fieldName","responseName","alias","args","argumentsFromAST","arguments","directives","INLINE_FRAGMENT","inlineFragmentType","effectiveType","FRAGMENT_SPREAD","fragmentType","visitedFragmentSet","get","set","mergeSelectionSets","fieldSet","filter","length","firstField","isConditional","some","directive","directiveName","bareType","subSelectionGroupedVisitedFragmentSet","subSelectionGroupedFieldSet","fragmentSpreadsForParentType","resolveInlineFragments","values","fragmentsReferencedFromFragment","fragmentReferenced","collectPossibleTypes","possibleTypes","isPossibleType","keys","typenameField","NAME","ast","isOperationRootType","getQueryType","getMutationType","getSubscriptionType","typeInfo","leave","SelectionSet","getParentType","sourceAt","location","body","slice","start","end","arg","concat","inlineFragment"],"mappings":"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","file":"compilation.js","sourcesContent":["import {\r\n  print,\r\n  visit,\r\n  visitWithTypeInfo,\r\n  typeFromAST,\r\n  getNamedType,\r\n  isAbstractType,\r\n  isEqualType,\r\n  isTypeSubTypeOf,\r\n  Kind,\r\n  TypeInfo,\r\n  isType,\r\n  isCompositeType,\r\n  GraphQLScalarType,\r\n  GraphQLEnumType,\r\n  GraphQLInputObjectType,\r\n  GraphQLObjectType,\r\n  GraphQLInterfaceType,\r\n  GraphQLUnionType,\r\n  GraphQLString,\r\n  GraphQLInt,\r\n  GraphQLFloat,\r\n  GraphQLBoolean,\r\n  GraphQLID,\r\n  GraphQLError\r\n} from 'graphql';\r\n\r\nimport {\r\n  isTypeProperSuperTypeOf,\r\n  getOperationRootType,\r\n  getFieldDef,\r\n  valueFromValueNode,\r\n  filePathForNode\r\n} from './utilities/graphql';\r\n\r\nimport {\r\n  join,\r\n  block,\r\n  wrap,\r\n  indent\r\n} from './utilities/printing';\r\n\r\nconst builtInScalarTypes = new Set([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);\r\n\r\nfunction isBuiltInScalarType(type) {\r\n  return builtInScalarTypes.has(type);\r\n}\r\n\r\n// Parts of this code are adapted from graphql-js\r\n\r\nexport function compileToIR(schema, document) {\r\n  const compiler = new Compiler(schema, document);\r\n\r\n  const operations = Object.create(null);\r\n\r\n  compiler.operations.forEach(operation => {\r\n    operations[operation.name.value] = compiler.compileOperation(operation)\r\n  });\r\n\r\n  const fragments = Object.create(null);\r\n\r\n  compiler.fragments.forEach(fragment => {\r\n    fragments[fragment.name.value] = compiler.compileFragment(fragment)\r\n  });\r\n\r\n  const typesUsed = compiler.typesUsed;\r\n\r\n  return { schema, operations, fragments, typesUsed };\r\n}\r\n\r\nexport class Compiler {\r\n  constructor(schema, document) {\r\n    this.schema = schema;\r\n\r\n    this.typesUsedSet = new Set();\r\n\r\n    this.fragmentMap = Object.create(null);\r\n    this.operations = [];\r\n\r\n    for (const definition of document.definitions) {\r\n      switch (definition.kind) {\r\n        case Kind.OPERATION_DEFINITION:\r\n          this.operations.push(definition);\r\n          break;\r\n        case Kind.FRAGMENT_DEFINITION:\r\n          this.fragmentMap[definition.name.value] = definition;\r\n          break;\r\n      }\r\n    }\r\n\r\n    this.compiledFragmentMap = Object.create(null);\r\n  }\r\n\r\n  addTypeUsed(type) {\r\n    if (type instanceof GraphQLEnumType ||\r\n        type instanceof GraphQLInputObjectType ||\r\n        (type instanceof GraphQLScalarType && !isBuiltInScalarType(type))) {\r\n      this.typesUsedSet.add(type);\r\n    }\r\n    if (type instanceof GraphQLInputObjectType) {\r\n      for (const field of Object.values(type.getFields())) {\r\n        this.addTypeUsed(getNamedType(field.type));\r\n      }\r\n    }\r\n  }\r\n\r\n  get typesUsed() {\r\n    return Array.from(this.typesUsedSet);\r\n  }\r\n\r\n  fragmentNamed(fragmentName) {\r\n    return this.fragmentMap[fragmentName];\r\n  }\r\n\r\n  get fragments() {\r\n    return Object.values(this.fragmentMap);\r\n  }\r\n\r\n  compileOperation(operationDefinition) {\r\n    const filePath = filePathForNode(operationDefinition);\r\n    const operationName = operationDefinition.name.value;\r\n    const operationType = operationDefinition.operation;\r\n\r\n    const variables = operationDefinition.variableDefinitions.map(node => {\r\n      const name = node.variable.name.value;\r\n      const type = typeFromAST(this.schema, node.type);\r\n      this.addTypeUsed(getNamedType(type));\r\n      return { name, type };\r\n    });\r\n\r\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, operationDefinition));\r\n\r\n    const rootType = getOperationRootType(this.schema, operationDefinition);\r\n\r\n    const groupedVisitedFragmentSet = new Map();\r\n    const groupedFieldSet = this.collectFields(rootType, operationDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\r\n\r\n    const fragmentsReferencedSet = Object.create(null);\r\n    const { fields } = this.resolveFields(rootType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\r\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\r\n\r\n    return { filePath, operationName, operationType, variables, source, fields, fragmentsReferenced };\r\n  }\r\n\r\n  compileFragment(fragmentDefinition) {\r\n    const filePath = filePathForNode(fragmentDefinition);\r\n    const fragmentName = fragmentDefinition.name.value;\r\n\r\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, fragmentDefinition));\r\n\r\n    const typeCondition = typeFromAST(this.schema, fragmentDefinition.typeCondition);\r\n\r\n    const groupedVisitedFragmentSet = new Map();\r\n    const groupedFieldSet = this.collectFields(typeCondition, fragmentDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\r\n\r\n    const fragmentsReferencedSet = Object.create(null);\r\n    const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(typeCondition, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\r\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\r\n\r\n    return { filePath, fragmentName, source, typeCondition, fields, fragmentSpreads, inlineFragments, fragmentsReferenced };\r\n  }\r\n\r\n  collectFields(parentType, selectionSet, groupedFieldSet = Object.create(null), groupedVisitedFragmentSet = new Map()) {\r\n    if (!isCompositeType(parentType)) {\r\n      throw new Error(`parentType should be a composite type, but is \"${String(parentType)}\"`);\r\n    }\r\n\r\n    for (const selection of selectionSet.selections) {\r\n      switch (selection.kind) {\r\n        case Kind.FIELD: {\r\n          const fieldName = selection.name.value;\r\n          const responseName = selection.alias ? selection.alias.value : fieldName;\r\n\r\n          const field = getFieldDef(this.schema, parentType, selection);\r\n          if (!field) {\r\n            throw new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${String(parentType)}\"`, [selection]);\r\n          }\r\n\r\n          if (groupedFieldSet) {\r\n            if (!groupedFieldSet[responseName]) {\r\n              groupedFieldSet[responseName] = [];\r\n            }\r\n\r\n            groupedFieldSet[responseName].push([parentType, {\r\n              responseName,\r\n              fieldName,\r\n              args: argumentsFromAST(selection.arguments),\r\n              type: field.type,\r\n              directives: selection.directives,\r\n              selectionSet: selection.selectionSet\r\n            }]);\r\n          }\r\n          break;\r\n        }\r\n        case Kind.INLINE_FRAGMENT: {\r\n          const typeCondition = selection.typeCondition;\r\n          const inlineFragmentType = typeCondition ?\r\n            typeFromAST(this.schema, typeCondition) :\r\n            parentType;\r\n\r\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : inlineFragmentType;\r\n\r\n          this.collectFields(\r\n            effectiveType,\r\n            selection.selectionSet,\r\n            groupedFieldSet,\r\n            groupedVisitedFragmentSet\r\n          );\r\n          break;\r\n        }\r\n        case Kind.FRAGMENT_SPREAD: {\r\n          const fragmentName = selection.name.value;\r\n\r\n          const fragment = this.fragmentNamed(fragmentName);\r\n          if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\r\n\r\n          const typeCondition = fragment.typeCondition;\r\n          const fragmentType = typeFromAST(this.schema, typeCondition)\r\n\r\n          if (groupedVisitedFragmentSet) {\r\n            let visitedFragmentSet = groupedVisitedFragmentSet.get(parentType);\r\n            if (!visitedFragmentSet) {\r\n              visitedFragmentSet = {};\r\n              groupedVisitedFragmentSet.set(parentType, visitedFragmentSet);\r\n            }\r\n\r\n            if (visitedFragmentSet[fragmentName]) continue;\r\n            visitedFragmentSet[fragmentName] = true;\r\n          }\r\n\r\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : fragmentType;\r\n\r\n          this.collectFields(\r\n            effectiveType,\r\n            fragment.selectionSet,\r\n            null,\r\n            groupedVisitedFragmentSet\r\n          );\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return groupedFieldSet;\r\n  }\r\n\r\n  mergeSelectionSets(parentType, fieldSet, groupedVisitedFragmentSet) {\r\n    const groupedFieldSet = Object.create(null);\r\n\r\n    for (const [,field] of fieldSet) {\r\n      const selectionSet = field.selectionSet;\r\n\r\n      if (selectionSet) {\r\n        this.collectFields(parentType, selectionSet, groupedFieldSet, groupedVisitedFragmentSet);\r\n      }\r\n    }\r\n\r\n    return groupedFieldSet;\r\n  }\r\n\r\n  resolveFields(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\r\n    const fields = [];\r\n\r\n    for (let [responseName, fieldSet] of Object.entries(groupedFieldSet)) {\r\n      fieldSet = fieldSet.filter(([typeCondition,]) => isTypeSubTypeOf(this.schema, parentType, typeCondition));\r\n      if (fieldSet.length < 1) continue;\r\n\r\n      const [,firstField] = fieldSet[0];\r\n      const fieldName = firstField.fieldName;\r\n      const args = firstField.args;\r\n      const type = firstField.type;\r\n\r\n      let field = { responseName, fieldName, type };\r\n\r\n      if (args && args.length > 0) {\r\n        field.args = args;\r\n      }\r\n\r\n      const isConditional = fieldSet.some(([,field]) => {\r\n        return field.directives && field.directives.some(directive => {\r\n          const directiveName = directive.name.value;\r\n          return directiveName == 'skip' || directiveName == 'include';\r\n        });\r\n      });\r\n\r\n      if (isConditional) {\r\n        field.isConditional = true;\r\n      }\r\n\r\n      const bareType = getNamedType(type);\r\n\r\n      this.addTypeUsed(bareType);\r\n\r\n      if (isCompositeType(bareType)) {\r\n        const subSelectionGroupedVisitedFragmentSet = new Map();\r\n        const subSelectionGroupedFieldSet = this.mergeSelectionSets(\r\n          bareType,\r\n          fieldSet,\r\n          subSelectionGroupedVisitedFragmentSet\r\n        );\r\n\r\n        const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(\r\n          bareType,\r\n          subSelectionGroupedFieldSet,\r\n          subSelectionGroupedVisitedFragmentSet,\r\n          fragmentsReferencedSet\r\n        );\r\n        Object.assign(field, { fields, fragmentSpreads, inlineFragments });\r\n      }\r\n\r\n      fields.push(field);\r\n    }\r\n\r\n    const fragmentSpreads = this.fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet);\r\n    const inlineFragments = this.resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\r\n\r\n    if (fragmentsReferencedSet) {\r\n      Object.assign(fragmentsReferencedSet, ...groupedVisitedFragmentSet.values());\r\n\r\n      // TODO: This is a really inefficient way of keeping track of fragments referenced by other fragments\r\n      // We need to either cache compiled fragments or find a way to make resolveFields smarter\r\n      for (let fragmentName of fragmentSpreads) {\r\n        const fragment = this.fragmentNamed(fragmentName);\r\n        if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\r\n        const { fragmentsReferenced: fragmentsReferencedFromFragment } = this.compileFragment(fragment);\r\n        for (let fragmentReferenced of fragmentsReferencedFromFragment) {\r\n          fragmentsReferencedSet[fragmentReferenced] = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return { fields, fragmentSpreads, inlineFragments };\r\n  }\r\n\r\n  resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\r\n    return this.collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet).map(typeCondition => {\r\n      const { fields, fragmentSpreads } = this.resolveFields(\r\n        typeCondition,\r\n        groupedFieldSet,\r\n        groupedVisitedFragmentSet,\r\n        fragmentsReferencedSet\r\n      );\r\n      return { typeCondition, fields, fragmentSpreads };\r\n    });\r\n  }\r\n\r\n  collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet) {\r\n    if (!isAbstractType(parentType)) return [];\r\n\r\n    const possibleTypes = new Set();\r\n\r\n    for (const fieldSet of Object.values(groupedFieldSet)) {\r\n      for (const [typeCondition,] of fieldSet) {\r\n        if (this.schema.isPossibleType(parentType, typeCondition)) {\r\n          possibleTypes.add(typeCondition);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Also include type conditions for fragment spreads\r\n    if (groupedVisitedFragmentSet) {\r\n      for (const effectiveType of groupedVisitedFragmentSet.keys()) {\r\n        if (this.schema.isPossibleType(parentType, effectiveType)) {\r\n          possibleTypes.add(effectiveType);\r\n        }\r\n      }\r\n    }\r\n\r\n    return Array.from(possibleTypes);\r\n  }\r\n\r\n  fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet) {\r\n    if (!groupedVisitedFragmentSet) return [];\r\n\r\n    let fragmentSpreads = new Set();\r\n\r\n    for (const [effectiveType, visitedFragmentSet] of groupedVisitedFragmentSet) {\r\n      if (!isTypeProperSuperTypeOf(this.schema, effectiveType, parentType)) continue;\r\n\r\n      for (const fragmentName of Object.keys(visitedFragmentSet)) {\r\n        fragmentSpreads.add(fragmentName);\r\n      }\r\n    }\r\n\r\n    return Array.from(fragmentSpreads);\r\n  }\r\n}\r\n\r\nconst typenameField = { kind: Kind.FIELD, name: { kind: Kind.NAME, value: '__typename' } };\r\n\r\nfunction withTypenameFieldAddedWhereNeeded(schema, ast) {\r\n  function isOperationRootType(type) {\r\n    return type === schema.getQueryType() ||\r\n      type === schema.getMutationType() ||\r\n      type === schema.getSubscriptionType();\r\n  }\r\n\r\n  const typeInfo = new TypeInfo(schema);\r\n\r\n  return visit(ast, visitWithTypeInfo(typeInfo, {\r\n    leave: {\r\n      SelectionSet: node => {\r\n        const parentType = typeInfo.getParentType();\r\n\r\n        if (!isOperationRootType(parentType)) {\r\n          return { ...node, selections: [typenameField, ...node.selections] };\r\n        }\r\n      }\r\n    }\r\n  }));\r\n}\r\n\r\nfunction sourceAt(location) {\r\n  return location.source.body.slice(location.start, location.end);\r\n}\r\n\r\nfunction argumentsFromAST(args) {\r\n  return args.map(arg => {\r\n    return { name: arg.name.value, value: valueFromValueNode(arg.value) };\r\n  });\r\n}\r\n\r\nexport function printIR({ fields, inlineFragments, fragmentSpreads }) {\r\n  return fields && wrap('<', join(fragmentSpreads, ', '), '> ')\r\n    + block(fields.map(field =>\r\n      `${field.name}: ${String(field.type)}` + wrap(' ', printIR(field))\r\n    ).concat(inlineFragments && inlineFragments.map(inlineFragment =>\r\n      `${String(inlineFragment.typeCondition)}` + wrap(' ', printIR(inlineFragment)))));\r\n}\r\n"]}